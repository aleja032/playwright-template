---
alwaysApply: true
---

# Reglas de Generación de Tests

## Orden de Generación OBLIGATORIO

Siempre generar código en este orden estricto:

1. **Page Object** (`pages/[Feature]Page.ts`)
2. **Fixture** (actualizar `fixtures/custom-fixtures.ts`)
3. **Test Spec** (`tests/[feature].spec.ts`)
4. **Data JSON** (`data-driven/[feature]-data.json`)

## Criterios de aceptación (AC) → Tests (trazabilidad)
- Los AC se trabajan como **Escenarios** con bullets verificables (por rol/flujo), como el ejemplo provisto.
- Cada test debe mapearse a un escenario/bullet (ideal: incluir `ESC-XX`/slug estable en el nombre del test).

Regla de clarificación (antes de generar):
- Si falta info (precondiciones, datos, mensajes, status codes, límites), **detener** y preguntar.
- El agente **NO debe crear** AC nuevos.
- Si faltan `data-testid` (Frontend), ir al **enlace proporcionado** y extraerlos; si sigue faltando info, detener y preguntar.
- No inventar endpoints, mensajes, ni `data-testid`.

### Formato Escenario (ejemplo)
- "Escenario: Acceso y visualización" → lista de bullets.
- Cada bullet debe ser un resultado esperado verificable (UI/API/E2E).

### Validaciones (agrupar y evitar redundancia)
Cuando un escenario incluye validaciones (tamaño de archivo, formatos, required fields, status codes), generar:
- 1 test happy path
- 1 test negativo **agrupado** por escenario/validación (evitar combinatoria sin valor)

Reglas de agrupación:
- Si hay múltiples campos obligatorios: **NO** crear 1 test por campo vacío. Preferir **1 solo test** que deje **todos** los campos obligatorios vacíos y valide **todas** las señales de error en el mismo flujo.
- Si hay múltiples validaciones similares (formatos/longitudes/rangos): preferir **un solo test parametrizado/data-driven** (array de casos) en lugar de duplicar tests casi idénticos.
- Solo separar en tests individuales si cada validación implica:
  - flujos distintos (navegación/estado diferente), o
  - mensajes/UX distintos que requieren pasos diferentes, o
  - precondiciones distintas que no conviene mezclar.
- Dentro del mismo test, usar `test.step()` para agrupar la lectura/validación por bullet (mantener trazabilidad con los AC).

## Estructura de Page Object

```typescript
import { Page, Locator } from '@playwright/test';
import { BasePage } from './BasePage';

export class [Feature]Page extends BasePage {
  readonly [elementName]: Locator;
  
  constructor(page: Page) {
    super(page);
    this.[elementName] = page.locator('[data-testid="element-id"]');
  }
  
  async [businessMethod](params) {
    // Encapsular flujos de negocio
  }
}
```

**REQUISITOS:**
- Extender `BasePage`
- Usar `data-testid` para selectores
- Exponer elementos como `readonly Locator`
- Encapsular flujos de negocio en métodos

## Estructura de Fixture

Agregar al archivo existente `fixtures/custom-fixtures.ts`:

```typescript
import { [Feature]Page } from '../pages/[Feature]Page';

type CustomFixtures = {
  // ... fixtures existentes
  [feature]Page: [Feature]Page;
};

export const test = base.extend<CustomFixtures>({
  // ... fixtures existentes
  [feature]Page: async ({ page }, use) => {
    const [feature]Page = new [Feature]Page(page);
    await use([feature]Page);
  },
});
```

## Estructura de Test

```typescript
import { test, expect } from '../fixtures/custom-fixtures';
import [feature]Data from '../data-driven/[feature]-data.json';

test.describe('[Feature] Tests', () => {
  test.beforeEach(async ({ [feature]Page }) => {
    await [feature]Page.goto('/[url]');
  });

  test('should [criterio de aceptación]', async ({ [feature]Page, page }) => {
    // Usar datos de [feature]Data
    // Usar métodos del Page Object
    // Assertions con expect
  });
});
```

**REQUISITOS:**
- Importar desde `custom-fixtures`
- Usar datos de JSON importado
- NO usar selectores raw en tests
- Tests paralelizables y determinísticos

## Estructura de Data JSON

```json
{
  "[scenarioName]": {
    "[field]": "[value]"
  }
}
```

**REQUISITOS:**
- Nombre descriptivo: `[feature]-data.json`
- NO incluir datos sensibles reales
- Estructura clara por escenario

## Nomenclatura

- **Page Objects**: PascalCase, sufijo `Page` (ej: `LoginPage`, `DashboardPage`)
- **Tests**: kebab-case, sufijo `.spec.ts` (ej: `login.spec.ts`)
- **Data JSON**: kebab-case, sufijo `-data.json` (ej: `login-data.json`)
- **Fixtures**: camelCase (ej: `loginPage`, `dashboardPage`)

## Validaciones Automáticas

Antes de generar, verificar:
- ✅ Page Object extiende `BasePage`
- ✅ Todos los selectores usan `data-testid`
- ✅ Test importa desde `custom-fixtures`
- ✅ Test usa datos de JSON importado
- ✅ No hay selectores raw en tests
- ✅ TypeScript strict mode compatible

## Referencias

- Constitución del proyecto: `.cursor/rules/playwright-rules.mdc`
- BasePage existente: `pages/BasePage.ts`
- Fixtures existentes: `fixtures/custom-fixtures.ts`
